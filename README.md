# PET-Project
Концепт PET-Project по автоматизации аналитики в компании

Добрый день!

Меня зовут Анастасия. Я 7 лет работаю data-аналитиком в небольшой русско-американской компании. Мое руководство поставило передо мной задачу по автоматизации аналитики в компании. Сейчас мы работаем только с 1C и всю аналитику я предоставляю в формате Excel-отчетов. Я хочу реализовать данный проект и представить его как pet-project для Яндекс Практикума.

Так как у нас совсем небольшая компания (у нас нет системных администраторов и вообще айтишников; только 1С-разработчик на аутсорсе), то весь пайплайн передачи данных от 1С до BI-системы я буду реализовывать самостоятельно.

Финальный проект для курса DE Яндекс.Практикума является прототипом рабочего проекта для моей компании. Я его готовила совместно со своими коллегами-студентами с курса - Анатолием Спесивцевым и Кириллом Жуль. Поэтому дальнейшее описание проекта будет происходить от нашей рабочей группы.

Пайплайн миграции данных выглядит следующим образом:
- на своей стороне 1С-разработчик реализует выгрузку данных (о продажах, стоках и т.д.) из 1С на FTP-хранилище в формате файлов csv согласно определенному таймингу (например, отчет о продажах будет выгружаться 3 раза в день: 7:00, 12:00, 16:00)
- далее мы с помощью аркестратора Apache Airflow забираем файлы с FTP в локальные папки на удаленном сервере (для каждого типа файла создана собственная директория: sales, forecast, marketplaces, category). Далее оттуда отдельным DAG мы направляем данные из csv файлов на STG-слой СУБД Postgres. И аркестратор, и СУБД развернуты в отдельных контейнерах Docker-compose.
- В СУБД созданы 3 слоя: staging, dds, cdm с витринами.

На слой STG данные загружаются "AS IS". 

Слой DDS представлен схемой "Снежинка", в которой ключевое место занимает таблица с показателями продаж, связанная через Foreign Keys со словарем clients и далее со словарем managers.

На слое STG есть таблица category. По сути, она также представляет собой словарь с данными о товарах (артикул, наименование, бренд, подбренд, категория товара). Это рукописный файл, который не выгружается из 1С, а составляется руками совместно с отделом маркетинга (так как пока нет возможности эту информацию интегрировать в 1С). По-хорошему, его также необходимо поместить на слой DDS. Но мы решили, согласно бритве Оккама, не плодить сущности, так как это будет абсолютно идентичная таблица на обоих слоях и оставить ее только на слое STG.

Данные в словари на слое DDS подгружаются инкрементально. Что же касается ключевой таблицы с показателями продаж на слое DDS, то она перед заливкой данных полностью очищается и данные заливаются без инкремента. Подобная загрузка связана со следующей ситуацией: 2023 год по бухгалтерской отчетности - незакрытый финансовый период; заказы в этот период постоянно корректируются менеджерами (например, заказ от марта 2023 может быть изменен в сентябре, так как менеджер договорился с клиентом о корректировке заказа). Такие ситуации происходят постоянно, каждый раз они разные (могут поменяться суммы заказов, могут быть проведены дополнительные скидки; товары могут быть просто удалены из заказов и т.д.) поэтому нет смысла прописывать все варианты подобных ситуаций в коде, проще делать ее truncate и insert.

На последнем слое - CDM - представлены агрегированные таблицы и готовые витрины данных на их основе. Эти витрины мы забираем в Datalens в качестве датасетов и на их основе создаем чарты, дашборды, чтобы предоставлять их конечным пользователям согласно выданным правам доступа.

## Технические особенности проекта

### DDS-слой

- в исходных данных csv файлов все числовые данные представлены с разделителем запятой вместо точки между целой и дробной частью. Ее мы заменяем через REPLACE
- в исходных данных csv файлов все даты представлены типом данных varchar, поэтому мы меняем их тип данных через to_date перед заливкой на dds-слой
- числовые данные на stg-слое также представлены типом данных varchar, поэтому перед их заливкой мы меняем их тип на numeric(14, 2) через cast(<> as double_precision)

### CDM-слой

#### all_months_aggregated_sales / "Агрегированные продажи за весь период (2017-2023 гг.) по месяцам"

Данная таблица является агрегирующей базой для последующих витрин (monthly_sales_by_brands, monthly_sales_by_sales_channels)

- в исходной таблице на слое dds orders_realizations у каждого товара в одной и той же строке есть и дата/номер заказа, и дата/номер реализации (отгрузки). Если товар не был отгружен, то, соответственно, у него есть дата/номер заказа, но нет даты/номера реализации.
- для данной таблицы нам необходимы только отгруженные товары, поэтому мы в нее заливаем только товары, у которых есть даты/номера реализации
- помимо тех товаров, у которых нет даты/номера реализации, в таблице "DDS".orders_realizations есть еще отчеты комиссионеров. Они также не имеют номера и даты реализации, но они являются отгруженными заказами. Поэтому в таблице они должны присутствовать. Это всего 2 клиента и мы через условия добавляем их отдельно к общей таблице

#### monthly_sales_by_sales_channels / "Продажи по каналам (продаж), по месяцам"

- для начала из предыдущей таблицы мы перенесли все данные о продажах, агрегированные по месяцам
- в данной витрине должны присутствовать отчеты комиссионеров, нам нужно их также добавить из таблицы "STG".marketplaces. Продажи комиссионеров в 1С у нас появляются не сразу после продажи, а с лагом в месяц - когда комиссионер присылает отчет. Но руководству нужно знать текущие продажи в данном канале, поэтому мы их запрашиваем у менеджеров; те в свою очередь нам предоставляют эти данные в файле csv. Мы загружаем этот файл на STG слой и оттуда забираем в витрину. При этом, важно сказать, что частично в 1С по одному из комиссионеров мы можем в текущем месяце видеть продажи, но они не полные. Поэтому мы сравниваем продажи в monthly_sales_by_sales_channels и в "STG".marketplaces, и оставляем в итоговой витрине бОльшую сумму (она актуальнее).
- продажи остальных комиссионеров мы просто добавляем в итоговую витрину (по условию, что они остсутствуют в итоговой витрине)

#### current_month_aggregated_sales / "Продажи текущего месяца"

Данная таблица является агрегирующей базой для последующей витрины (monthly_sales_report)

- Эта витрина агрегированна по менеджеру, клиенту и бренду. Она нам необходима для создания итогового отчета по продажам, в котором мы будем сравнивать текущие продажи с прогнозом, который выставило руководство и менеджеры
- В итоговой витрине мы хотим видеть отдельный столбец по заказам (не отгруженным) и отдельный столбец - по реализациям (отгруженным). Но сумма заказа у нас находится в единственном столбце total_sum, поэтому с помощью конструкции case, мы распределяем данные total_sum по отдельным столбцам
- добавляем в витрину данные комиссионеров (сначала сравниваем продажи в "CDM".current_month_aggregated_sales и "STG".marketplaces; выбираем бОльшую сумму продаж комиссионеров, которые присутствуют в "CDM".current_month_aggregated_sales)
- добавляем в витрину данные продаж комиссионеров из "STG".marketplaces, которых нет в итоговой витрине


Вся работа над проектом выполнялась нами локально на личных компьютерах (VSCode/DBeaver) в директориях, в которые был склонирован данный репозиторий Github. При выполнении определенного блока мы пушили его в текущий репозиторий (git add ./git commit -m "Best commit"/git push origin master), а потом забирали его на удаленный сервер в директорию, где развернут docker compose (git remote update/git pull).
